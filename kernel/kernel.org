* 基础
字节顺序是指一个字中各个字节的顺序。

+ 所有的unix内核都是可重入的(reentrant)，这意味着若干进程可以同时在内核态下执行
+ init监控所有子进程的执行，并且按常规发布wait4()系统调用，其副作用就是除掉所有僵死的进程。

* 进程和线程

内核线程和普通的进程间的区别在于内核线程没有独立的地址空间（实际上指向地址空间的mm指针被设置为NULL）。它们只在内核空间运行，从来不切换到用户空间去。内核线程和普通进程一样，可以被调度，也可以被抢占。

进程的虚拟地址空间包括了进程可以引用的所有虚拟内存地址。内核通常用一组内存区描述符描述进程虚拟地址空间。内核分配给进程虚拟地址空间由以下内存区组成
+ 程序的可执行代码
+ 程序的初始化数据
+ 程序的未初始化数据
+ 初始化程序栈（即用户态栈）
+ 所需共享库的可执行代码和数据
+ 堆（由程序动态请求的内存）

** 进程优先级
linux采用了两种不同的优先级范围：
1. 第一种使用nice值，它的范围是从-20到+19，默认值为0；越大的nice值意味着更低的优先级
2. 第二种是实时优先级，其值是可匹配的，默认情况下它的变化范围是从0到99（包括0和99）

内核使用的优先级和用户态使用的优先级不同。内核使用一个简单些的数值范围，从0到139（包含0和139）用来表示内核内部优先级。数值越低，优先级越高。0-99的范围专供实时优先级使用。nice值[-20, +19]映射到范围100到139，如下图所示。实时进程的优先级总是比普通进程更高。
#+BEGIN_SRC
              <---- 高优先级----            -20    Nice     19
 ____________________________________________________________
|                     实时                   ｜     普通     ｜
 ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
0                                          99 100            139
 #+END_SRC

内核中，进程有三种优先级。分别是：
+ 动态优先级(task_struct->prio)
+ 普通优先级(task_struct->normal_prio)
+ 静态优先级(task_struct->static_prio)

系统调用设置的是进程的静态优先级，进程内的静态优先级是计算其他优先级的起点。普通优先级将静态优先级换算为进程内部使用的优先级，也即上图中的表示。动态优先级用来解决优先级反转问题。

** 进程状态
进程描述符中的state描述了进程的当前状态。系统中的每个进程都必然处于五种状态中的一种。
+ TASK_RUNNING——进程是可执行的，它或者正在执行，或者在运行队列中等待执行。这是进程在用户空间执行的唯一可能状态。这种状态也可以应用到内核空间中正在执行的进程。
+ TASK_INTERRUPTIBLE——进程正在睡眠（也就是它被阻塞），等待某些条件的达成。一旦这些条件达成，内核就会把进程状态设置为运行。处于此状态的进程也会因为接收到信号而提前被唤醒并随时准备投入运行。
  
* 内存
** 内存地址
*** 逻辑地址/logical address
包含在机器语言指令中用来指定一个操作数或者一条指令的地址。每一个逻辑地址都有一个段(segment)和偏移量(offset or displacement)组成，偏移量指明了从段开始的地方到实际地址之间的距离。

*** 线性地址/linear address or 虚拟地址/virtual address
是一个32位无符号整数，可以用来表示高达4GB的地址空间

虚拟内存有很多用途和优点：
+ 若干进程可以并发执行
+ 应用程序所需内存大于可用物理内存时也可以运行
+ 程序只有部分代码装入内存时进程可以执行它
+ 允许每个进程访问可用物理内存的子集
+ 进程可以共享库函数或程序的一个单独内存映像
+ 程序是可重定位的，也就是说，可以把程序放在物理内存的任何地方
+ 程序员可以编写与机器无关的代码，因为他们不必关心物理内存的组织结构


*** 物理地址/physical address
用于内存芯片级内存单元寻址。它们与从微处理器的地址引脚发送到内存总线上的电信号相对应。物理地址由32位或36位无符号整数表示。


** 页面交换和页面回收
页面交换通过利用磁盘空间作为扩展内存，从而增大了可用内存。在内核需要更多内存是，不经常使用的页可以写入硬盘。如果再需要访问相关数据，内核会将相应的页切换回内存。

页面回收用于将内存映射被修改的内容与底层的块设备同步，为此有时也称为数据回写。

内核中的内存都不分页。也就是说，每用掉一个字节，物理内存就减少一个字节。

* 中断
内核中有类似可能造成并发执行的原因
+ 中断——中断几乎可以在任何时刻异步发生，也就是可能随时打断当前正在执行的代码
+ 软中断和tasklet——内核能在任何时刻唤醒或调度软中断和tasklet，打断当前正在执行的代码
+ 内核抢占——因为内核具有抢占性，所以内核中的任务可能会被另一任务抢占
+ 睡眠及与用户空间的同步——在内核执行的进程可能会睡眠，这就会唤醒调度程序，从而导致调度一个新的用户进程执行
+ 对称多处理——两个或多个处理器可以同时执行代码

一个中断处理程序既可以抢占其他的中断处理程序，也可以抢占异常处理程序。相反，异常处理程序从不抢占中断处理程序。在内核态能触发的唯一异常就是缺页异常。但是，中断处理程序从不执行可以导致缺页（因此意味着进程切换）的操作。

在中断处理程序中能避免并发访问的安全代码称作中断安全码(interrupt-safe)，在对称多处理的机器中能避免并发访问的安全代码称为SMP安全代码(SMP-safe)，在内核抢占时能避免并发访问的安全代码称为抢占安全代码(preempt-safe)。

* 锁
** 自旋锁
由于下半部可以抢占进程上下文中的代码，所以当下半部和进程上下文共享数据时，必须对进程上下文中的共享数据进行保护，所以需要加锁的同时还要禁止下半部执行。同样，由于中断处理程序可以抢占下半部，所以如果中断处理程序和下半部共享数据，那么就必须在获取恰当的锁的同时还要禁止中断。
* 块I/O
块设备中最小的可寻址单元是扇区。扇区大小一般是2的整数倍，而最常见的是512字节。扇区的大小是设备的物理属性，扇区是所有块设备的基本单元——块设备无法对比它还小的单元进行寻址和操作，尽管许多块设备能够一次对多个扇区进行操作。

因为各种软件的用途不同，所以它们都会用到自己的最小逻辑可寻址单元——块。块是文件系统的一种抽象——只能基于块来访问文件系统。虽然物理磁盘寻址是按照扇区级进行的，但是内核执行的所以磁盘操作都是按照块进行的。由于扇区是设备的最小可寻址单元，所以块不能比扇区还小，只能数倍于扇区大小。另外，内核（对有扇区的硬件设备）还要求块大小是2的整数倍，而且不能超过一个页的长度。所以，对块大小的最终要求是，必须是扇区大小的2的整数倍，并且要小于页面大小。所以通常块大小是512字节、1KB或4KB。

