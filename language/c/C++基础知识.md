## 指针和引用

**指针**：本身是一个对象，指向内存的一个存储单元；
**引用**：为对象起了另外一个名字，引用类型引用另外一种名字；

区别：
1. 指针本身是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内可以先后指向几个不同的对象，而引用初始化后不能重新绑定到另外一个对象。
2. 指针无须在定义时赋值，和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，会拥有一个不确定的值。而引用必须初始化。
3. 可以用constraint指针，但是没有const引用。（因为一个是对象而另一个不是对象）。
4. 指针可以有多级，但引用只能是一级。 （`int **p`合法而`int &&a`不合法)
5. 指针的值可以为空，但是引用的值不能为空。
6. 对指针sizeof得到指针本身的大小，而对引用sizeof得到引用所引对象的大小。
7. 指针和引用的自增(++)运算意义不一样。
8. 如果返回动态内存分配的对象或内存，必须使用指针，引用可能引起内存泄漏。(?)

## const限定符

**const**限定符表示变量的值不能改变。
* 因为const对象一旦创建后其值不能改变，所以const对象必须初始化。
* **编译器会在编译过程中把用到const变量的地方替换为对象的值**
* 因为上一个原因，默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。
* 如果需要只在一个文件中定义const，而在其他多个文件中声明并使用它，解决办法是：对于const变量不管是在声明还是定义都添加extern关键字。

1. const的引用：引用绑定到一个const对象上。
2. 引用本身不能用const修饰，因为引用本身天生就是const的。
3. 指针本省可以是const的，指向的对象也可以是固定的，区别是const在*前还是后。
4. *顶层const*表示指针本身是个常量。
5. *底层const*表示指针所指的对象是个常量。

## extern关键字

**extern**关键字用在变量或者函数的声明前，用来说明*此变量/函数是在别处定义的，要在此处引用*。extern声明不是定义，不分配存储空间。

也就是说，在一个文件中定义了变量或函数，在其他文件中要使用它们，可以有两种方式：
* 使用头文件，在头文件中声明变量或函数，然后其他文件包含头文件。
* 在其他文件中直接extern

extern "C"的作用：告诉编译器不要修改函数名称。

## 宏和const常量

```C
#define RADIUS 100;
const float RADIUS = 100.0f;
```

1. 编译器处理方式不同：define宏在预处理阶段展开，而const常量是编译运行阶段使用。
2. 类型和安全检查不同：define宏没有类型，不做任何类型检查，仅仅展开做替换，而const常量有具体的类型，在编译阶段会执行类型检查。
3. 存储方式不同：define宏仅仅是展开，不会分配内存。（宏定义不分配内存，变量定义分配内存）const常量会在内存中分配（可以是对也可以是栈)。
4. const可以节省空间，避免不必要的内存分配。const常量从汇编的角度来看，只是给出了对应的内存地址，而不是像#define一样给出的是立即数，所以const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干份拷贝。
5. 编译器通常不为普通const常量分配内存空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读写的操作，使得它的效率也很高。
6. #define定义的宏是全局的，而const常量可以定义在类中。
