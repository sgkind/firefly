# RT patch

## RT patch为实现实时性做的工作
### 将中断转化为线程

上半部的工作：IRQ
下半部的工作：内核线程、tasklet和softirq

softirq：内核会唤醒一个ksoftirqd线程，RT patch让所有的softirq运行于ksoftirq线程下。因此会存在如下问题：所有的softirq都具有一样的优先权，而且每个cpu只有一个线程在处理这些softiqr

tasklet：同一softirq可以同时运行在两个不同的cpu之上，而tasklet不能。所以，tasklet必须使用上锁机制，以防止任何全局数据或者其他资源的并行存取，而tasklet不必这么做；换言之，tasklet不必是可重入的。

内核线程：开销比tasklet和softirq大。在非实时内核中，softirq和tasklet无法被具有任何优先级的任何线程抢占。所以采用内核线程的操作将更加灵活。

### 将硬件中断请求转化为线程

硬件中断请求是一种会随附IRQ的中断，它的持续时间是从中断抢占cpu到ISR返回到cpu进行正常的处理。显然我们无法避免硬件中断抢占cpu，但是RT patch将优先级逆转的时间缩短到最低限度。当一个中断被触发时，ISR所做的事情就是屏蔽中断线以及唤醒中断服务线程。

### 中断与cpu亲和性

一个IRQ线程的cpu亲和性由中断本身的cpu亲和性决定。所以，如果想要设定中断服务线程的亲和性，只需要设定中断的亲和性。在中断被触发之前，线程的亲和性不会被更新为中断的亲和性。

## 编写实时进程需要满足的条件
1. 进程采用实时调度策略及实时优先级
2. 锁内存，确保不会出现缺页错误从而不能满足实时性需求
3. 预分配堆栈，防止堆栈错误导致实时性得不到满足

## 实时进程会不会造成系统soft lockup
soft lockup发生在内核线程[watchdog/x]得不到运行的情况下，理论上如果实时进程占着cpu不放，确实有可能导致[watchdog/x]得不到运行而发生soft lockup，然而这个可能性并不大，因为[watchdog/x]本身也是实时进程，调度策略为SCHED_FIFO，优先级已经是最高的99

如果占着cpu不放的实时进程也是SCHED_FIFO并且优先级为99，就有可能导致soft lockup，原因：
* 在多个实时进程之间，优先级更高的会抢先运行
* 优先级相同的实时进程之间，不会互相抢占，只能等对方主动释放cpu
* SCHED_FIFO调度策略的特点是，进程会一直保持运行直到发生一下情况之一
  1. 进程主动调用sched_yield()放弃运行，自动排到运行队列的队尾，等到相同优先级的其他进程运行之后才有机会再运行
  2. 进程进入睡眠状态（比如由于等待I/O的原因），唤醒后自动排到队列的队尾，等到相同优先级的其他进程运行之后才有机会再运行
  3. 被优先级更高的实时进程抢占，这种情况下会自动排到运行队列的队首，下次运行的机会排在相同优先级的其他进程的前面
* SCHED_RR和SCHED_FIFO唯一不同的是，实时进程的运行事件分成一段一段的，在相同优先级的进程之间轮流运行，每个进程运行完一个时间片之后，必须让给下一个进程（强调：仅对相同优先级而言，不同优先级的进程之间仍然会相互抢占）

所以，如果占着cpu不妨的实时进程的调度策略是SCHED_FIFO，并且优先级为与[watchdog/x]相同的99，SCHED_FIFO的调度策略决定了它只要不放手，[watchdog/x]就无法运行，结果会导致soft lockup.